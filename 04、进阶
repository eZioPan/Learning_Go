指针

Go 有指针，一个指针类型这样定义 *<类型>
任何一个没有赋值的指针的值都为 nil
若要在指针内存储一个对象的地址，需要使用 & 操作符取对象的地址
若要取出一个指针所指向的值，可以在指针变量名前加 *

EG.

var p *int		// 声明了一个指向 int 类型的指针 p
fmt.Println(p)	// 打印了 nil，也就是指针类型变量的初始值
var i int
p = &i			// 用 & 取了 整数型变量 i 的地址，并存储到 p 中
fmt.Println(p)	// 打印出了一个十六进制数，代表 p 存储的内存地址
v = *p			// 通过对指针变量名前加 * ，取出 指针 指向的数据值
fmt.Println(v)	// 打印出 0，也就是 上述 i 的值
*p = 8			// 通过指针取值，直接修改原数据值
fmt.Println(i)	// 已修改原变量 i 的值为 8
fmt.Println(*p)	// *p 的值自然为 8
fmt.Println(v)	// 保存的是修改前的值，为 0



内存分配

Go 语言中，有 GC 机制，我们不需要要手动管理内存回收

Go 语言中，内存用 new 和 make 两个内建函数来分配

new

语法 new(<类型>)

new 用于分配内存给指定类型，并用该类型的零值填充该内存区域，
	并返回指向该内存的地址，一个 *<类型> 的指针

make

语法 make(<类型>[,<长度>][,<容量>])

make 用于为 slice、map、channel 三种类型分配内存
并返回生成的对象

本质上来说，slice map 和 channel 在分配内存之后，都需要做初始化处理
make 的作用就是在分配内存后，还做了一系列初始化动作
