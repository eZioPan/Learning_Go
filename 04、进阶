指针

Go 有指针，一个指针类型这样定义 *<类型>
任何一个没有赋值的指针的值都为 nil
若要在指针内存储一个对象的地址，需要使用 & 操作符取对象的地址
若要取出一个指针所指向的值，可以在指针变量名前加 *

EG.

var p *int		// 声明了一个指向 int 类型的指针 p
fmt.Println(p)	// 打印了 nil，也就是指针类型变量的初始值
var i int
p = &i			// 用 & 取了 整数型变量 i 的地址，并存储到 p 中
fmt.Println(p)	// 打印出了一个十六进制数，代表 p 存储的内存地址
v = *p			// 通过对指针变量名前加 * ，取出 指针 指向的数据值
fmt.Println(v)	// 打印出 0，也就是 上述 i 的值
*p = 8			// 通过指针取值，直接修改原数据值
fmt.Println(i)	// 已修改原变量 i 的值为 8
fmt.Println(*p)	// *p 的值自然为 8
fmt.Println(v)	// 保存的是修改前的值，为 0



内存分配

Go 语言中，有 GC 机制，我们不需要要手动管理内存回收

Go 语言中，内存用 new 和 make 两个内建函数来分配

new

语法 new(<类型>)

new 用于分配内存给指定类型，并用该类型的零值填充该内存区域，
	并返回指向该内存的地址，一个 *<类型> 的指针

make

语法 make(<类型>[,<长度>][,<容量>])

make 用于为 slice、map、channel 三种类型分配内存
并返回生成的对象

本质上来说，slice map 和 channel 在分配内存之后，都需要做初始化处理
make 的作用就是在分配内存后，还做了一系列初始化动作



定义新类型

type <新类型名称> <新类型数据结构>

EG.

type MyInt int	// 一个底层为 int 类型的 MyInt 类型


与新类型常连用的是称为 结构体类型，来定义复杂类型


结构体


结构体的声明

struct {
	[<字段名称>] <字段对应的类型>
	...
}

eg1.

type Person struct{		// 声明了一个新的类型 Person，它是一个结构体
						// 该类型的类型名大写，是可导出新类型
	uuid string			// 结构体里包含的字段1：uuid，类型为 string
						// 由于首字母是小写，所以是非导出字段
	Id int				// 以下字段都是可导出字段
	Name string
	Phone int
	Address string
	string				// 匿名字段，其类型为 string，而字段名随着类型，也叫做 string
}						// 注意，无论是匿名字段还是非匿名字段，都不可以重名
