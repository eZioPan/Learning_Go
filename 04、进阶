指针

Go 有指针，一个指针类型这样定义 *<类型>
任何一个没有赋值的指针的值都为 nil
若要在指针内存储一个对象的地址，需要使用 & 操作符取对象的地址
若要取出一个指针所指向的值，可以在指针变量名前加 *

EG.

var p *int		// 声明了一个指向 int 类型的指针 p
fmt.Println(p)	// 打印了 nil，也就是指针类型变量的初始值
var i int
p = &i			// 用 & 取了 整数型变量 i 的地址，并存储到 p 中
fmt.Println(p)	// 打印出了一个十六进制数，代表 p 存储的内存地址
v = *p			// 通过对指针变量名前加 * ，取出 指针 指向的数据值
fmt.Println(v)	// 打印出 0，也就是 上述 i 的值
*p = 8			// 通过指针取值，直接修改原数据值
fmt.Println(i)	// 已修改原变量 i 的值为 8
fmt.Println(*p)	// *p 的值自然为 8
fmt.Println(v)	// 保存的是修改前的值，为 0



内存分配

Go 语言中，有 GC 机制，我们不需要要手动管理内存回收

Go 语言中，内存用 new 和 make 两个内建函数来分配

new

语法 new(<类型>)

new 用于分配内存给指定类型，并用该类型的零值填充该内存区域，
	并返回指向该内存的地址，一个 *<类型> 的指针

make

语法 make(<类型>[,<长度>][,<容量>])

make 用于为 slice、map、channel 三种类型分配内存
并返回生成的对象

本质上来说，slice map 和 channel 在分配内存之后，都需要做初始化处理
make 的作用就是在分配内存后，还做了一系列初始化动作



定义新类型

type <新类型名称> <新类型数据结构>

EG.

type MyInt int	// 一个底层为 int 类型的 MyInt 类型


与新类型常连用的是称为 结构体类型，来定义复杂类型


结构体


结构体的声明

struct {
	[<字段名称>] <字段对应的类型>
	...
}

eg1.

type Person struct{		// 声明了一个新的类型 Person，它是一个结构体
						// 该类型的类型名大写，是可导出新类型
	uuid string			// 结构体里包含的字段1：uuid，类型为 string
						// 由于首字母是小写，所以是非导出字段
	Id int				// 以下字段都是可导出字段
	Name string
	Phone int
	Address string
	string				// 匿名字段，其类型为 string，而字段名随着类型，也叫做 string
}						// 注意，无论是匿名字段还是非匿名字段，都不可以重名


结构体中字段的赋值

1、字面值赋值

<结构类型名>{
	<字段名a>:<值a>,		// 可乱序排列，但不可忽略字段名
	...
}

或者

<结构类型名>{
	<值1>，				// 可忽略字段名，但不可乱序排列
	...
}

2、类 OO 赋值，该方法也是取用字段名对应的值的方法

<结构对象名>.<字段名> = <值>


eg2.

// 接 eg1

var p1 Person = Person{
	uuid:1234-1234-12341234-1234,
	string:"Wow!FirstMan!",				// 有字段名即可乱序赋值
	Phone:1234567890,
}

p2 := Person{
	1234-1234-12341234-1234,			// 不乱序可省略字段名
	001,
	"XA",
	"Wow! A Place",
}

var p3 Person

p3.Name = “NNa”				// 调用修改


有关于结构体中，匿名字段的名称问题

struct{
	T1		// 名称为 T1
	*T2		// 名称为 T2
	P.T3	// 名称为 T3
}



方法

有一类特殊的函数，它们与某种类型绑定，是某种类型专有的函数，它们被称为 方法

eg3.

// 接 eg1

func (p *Person) ChangeName(newName string){	// 接受一个 Person 类型的指针
	p.Name = newName							// 此处 (*p).Name 可以简写为 p.Name
}


// 使用方法

var p1 *Person			// 建立一个对象

p1.ChangeName("AAAA")	// 调用对象的方法
