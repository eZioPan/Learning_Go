总览

bytes 包实现了操作 []byte 的函数
它与 strings 包的构架类似



常量

MinRead 是调用 Buffer.ReadFrom 时传入 Read 中的最小的 slice 大小
只要 Buffer 具有的空间超过，持有 r 的内容容量，至少 MinRead 字节的空间，
ReadFrom 就不会增长底层的 buffer

const MinRead = 512



变量

若无法为缓存分配子厚存储数据的内存，ErrTooLarge 就会被传入 panic 中

var ErrTooLarge = errors.New("bytes.Buufer: too large")



Compare(a,b []byte) int
返回一个整数，按字典顺序比较两个 []byte
若 a == b，则为 0
若 a < b，则为 -1
若 a > b，则为 +1
一个 nil 参数等价于空字符串

EG.

// 将 Compare 的结果与 0 做比较，来解析结果
var a, b []byte
if bytes.Compare(a, b) < 0 {
	// a 小于 b
}
if bytes.Compare(a, b) <= 0 {
	// a 小于等于 b
}
if bytes.Compare(a, b) > 0 {
	// a 大于 b
}
if bytes.Compare(a, b) >= 0 {
	// a 大于等于 b
}

// 对于等价比较，使用 Equal 优于 Compare
if bytes.Equal(a, b) {
	// a 等于 b
}
if !bytes.Equal(a, b) {
	// a 不等于 b
}


EG.【Search】

// 二进制搜索已找到匹配的 []byte
var needle []byte
var haystack [][]byte // 假设已经排序
i := sort.Search(len(haystack), func(i int) bool {
	// 返回 haystack[i] >= needle.
	return bytes.Compare(haystack[i], needle) >= 0
})
if i < len(haystack) && bytes.Equal(haystack[i], needle) {
	// 找到啦！
}



Contains(b, subslice []byte) bool
报告 b 中是否包含子切片

EG.

fmt.Println(bytes.Contains([]byte("seafood"), []byte("foo")))
fmt.Println(bytes.Contains([]byte("seafood"), []byte("bar")))
fmt.Println(bytes.Contains([]byte("seafood"), []byte("")))
fmt.Println(bytes.Contains([]byte(""), []byte("")))



ContainsAny(b []byte, chars string) bool
报告 b 中是否包含 chars 中具有的任何 UTF-8 编码的 Unicode 码点



ContainsRune(b []byte, r rune) bool
报告 b 中是否含有 Unicode 码点 r



Count(s, sep []byte) int
计算 s 中非重叠出现的 sep
若 sep 时空 slice，本函数返回 1 + s 中出现的 Unicode 码点数

EG.

fmt.Println(bytes.Count([]byte("cheese"), []byte("e")))
fmt.Println(bytes.Count([]byte("five"), []byte(""))) // 在每个 rune 之前和之后



Equal(a, b []byte) bool
返回一个布尔值报告了 a 和 b 是否具有相同长度且具有相同的内容
一个 nil 参数等价于一个空 slice



EqualFold(s, t []byte) bool
报告 s 和 t，解析为 UTF-8 字符串时，是否在 Unicode case-folding 的情况下等价

EG.

fmt.Println(bytes.EqualFold([]byte("Go"), []byte("go")))



Fields(s []byte) [][]byte
通过以一个或多个连续的 white space 字符作为分隔符，分割 s，返回获得的子 slice s，
若 s 仅含有 white space，则返回空列表

EG.

fmt.Printf("Fields are: %q", bytes.Fields([]byte("  foo bar  baz   ")))



FieldsFunc(s []byte, f func(rune) bool) [][]byte
把 s 解析 UTF-8 编码的 Unicode 码点序列
每当遇到满足 f(c) 的码点 c，本函数都在 c 处分离 slice s，并返回 s 的子 slice 所组成的 slice
若所有 s 中的码点都满足 f(c)，或者 len(s)==0，那么返回一个空 slice
本函数不保证它调用 f(c) 的顺序
对于给定的 c，若 f 不能稳定返回值，则本函数可能崩溃

EG.

f := func(c rune) bool {
	return !unicode.IsLetter(c) && !unicode.IsNumber(c)
}
fmt.Printf("Fields are: %q", bytes.FieldsFunc([]byte("  foo1;bar2,baz3..."), f))



HasPrefix(s, prefix []byte) bool
测试 slice s 是否以 prefix 开始

EG.

fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("Go")))
fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("C")))
fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("")))



HasSuffix(s, suffix []byte) bool
测试 slice s 是否以 suffix 结束

EG.

fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("go")))
fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("O")))
fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("Ami")))
fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("")))



Index(s, sep []byte) int
返回 s 中第一个 sep 的实例的索引，若 sep 并未出现在 s 中，则返回 -1

EG.

fmt.Println(bytes.Index([]byte("chicken"), []byte("ken")))
fmt.Println(bytes.Index([]byte("chicken"), []byte("dmr")))



IndexAny(s []byte, chars string) int
将 s 解析为 UTF-8 编码的 Unicode 码点序列
返回 s 中首个出现的任何存在于 chars 中的 Unicode 码点的索引
若 chars 为空，或者未能找到共有的码点时，返回 -1

EG.

fmt.Println(bytes.IndexAny([]byte("chicken"), "aeiouy"))
fmt.Println(bytes.IndexAny([]byte("crwth"), "aeiouy"))



IndexByte(s []byte, c byte) int
IndexFunc(s []byte, f func(r rune) bool) int
同上，但针对不同类型来进行测试和返回



IndexRune(s []byte, r rune) int
特别的，当 r 是 utf8.RuneError，它返回第一个遇到的非法 UTF-8 字节序列



LastIndex(s, sep []byte) int
LastIndexAny(s []byte, chars string) int
LastIndexByte(s []byte, c byte) int
LastIndexFunc(s []byte, f func(r rune) bool) int
同上，但返回的是最后一个对应的内容的索引



Join(s [][]byte, sep []byte) []byte
将 s 的元素合并为一个新的 []byte
分隔符将置于结果 slice 的两个元素之间



Map(mapping func(r rune) rune, s []byte) []byte
返回 slice s 的一个拷贝，其中的每个字符都经过 mapping 函数的修改
若 mapping 返回了一个负值，字符会直接从字符串中丢弃
s 和 输出的字符都被解析为 UTF-8 编码的码点

EG.

rot13 := func(r rune) rune {
	switch {
	case r >= 'A' && r <= 'Z':
		return 'A' + (r-'A'+13)%26
	case r >= 'a' && r <= 'z':
		return 'a' + (r-'a'+13)%26
	}
	return r
}
fmt.Printf("%s", bytes.Map(rot13, []byte("'Twas brillig and the slithy gopher...")))



Repeat(b []byte, count int) []byte
返回一个新的 []byte，其中包含 count 个 b
若 count 为负值或者 len(b) * count 溢出，则产生 panic

EG.

fmt.Printf("ba%s", bytes.Repeat([]byte("na"), 2))



Replace(s, old, new []byte, n int) []byte
返回 slice s 的拷贝，其中前 n 个非重叠的 old 会被替换为 new
若 old 为空，则它匹配上 slice 的开头，以及每个 UTF-8 序列的后面，
对于 k 字符长度的 slice，产生 k + 1 个替换
若 n < 0，就不限制替换的数量

EG.

fmt.Printf("%s\n", bytes.Replace([]byte("oink oink oink"), []byte("k"), []byte("ky"), 2))
fmt.Printf("%s\n", bytes.Replace([]byte("oink oink oink"), []byte("oink"), []byte("moo"), -1))



Runes(s []byte) []rune
返回等价于 s 的 []rune（Unicode code points）



Split(s, sep []byte) [][]byte
通过寻找 sep 来分割 slice s，并返回分隔符之间的子 slice
若 sep 为空，本函数在每个 UTF-8 序列后分割
本函数等价于 SplitN 的 n 值为 -1 时的情况

EG.

fmt.Printf("%q\n", bytes.Split([]byte("a,b,c"), []byte(",")))
fmt.Printf("%q\n", bytes.Split([]byte("a man a plan a canal panama"), []byte("a ")))
fmt.Printf("%q\n", bytes.Split([]byte(" xyz "), []byte("")))
fmt.Printf("%q\n", bytes.Split([]byte(""), []byte("Bernardo O'Higgins")))



SplitAfter(s, sep []byte) [][]byte
在每个 sep 的实例之后切开 s，并返回所有的子 slice

EG.

fmt.Printf("%q\n", bytes.SplitAfter([]byte("a,b,c"), []byte(",")))



SplitN(s, sep []byte, n int) [][]byte
SplitAfterN(s, sep []byte, n int) [][]byte
类比上两个函数
