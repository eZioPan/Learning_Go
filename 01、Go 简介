Golang -- Go 语言的特点

1、 并发
	Go 语言让含糊容易成为轻量的线程
	这些线程被称为 goroutines

2、 Channel
	goroutines 之间的通信通过 channel 达成

3、 垃圾回收
	Go 带有垃圾回收机制，也就是 Go 编译的程序自带 runtime

4、 自带代码格式化工具
	Go 自带 gofmt 工具，可以格式化代码，让它符合官方指定的标准

5、 类型后置
	在声明变量的时候，变量名处在变量类型的前面
	这样避免了很多嵌套时的语句混淆

6、 严格的类型
	Go 有着严格的类型限定
	类型之间必须显式转换

7、 UTF-8 支持
	Go 语言的字符串和代码本身都是 UTF-8 的
	也就是字符串和代码都可以书写 UTF-8 支持的字符



Hello,world

新建 helloworld.go 文件
写入以下内容

package main

import "fmt"	//格式化 IO

/* 打印 */

func main() {
	fmt.Printf("Hello,世界！")
}


注意
1、 文件的首行必然以 package xxx 开头
	在 Go 中，每个源码文件都是一个“包”
	每个包必须在第一行用 package xxx 表明包的名称

1.1 一个程序的入口，也就是主程序
	必须以 main 作为包的名称

2、 默认情况下
	Go 不需要在行尾写分号 ;
	除非需要将多个语句放在同一行书写

3、 import 语句用于导入其他包
	fmt 包是 Go 自带的格式化 IO 包
	用于提供可格式化的输出等功能

3.1 import 的包必须被调用过
	否则就会在编译时报错

4、 一行中 若出现 //
	则后面的内容均为注释

5、 注释也可以以 /* 开头
	以 */ 结尾

6、 Go 用函数组织程序
	用 func 语句声明一个函数

6.1 每个主程序的入口必须是 main 函数
	这个函数不接受任何的传入值

7、 所有的左括号不可以另起一行写
	这是由于 Go 是自动添加分号的
	若另起一行写左括号
	Go 会在上一行加上分号
	而断开代码块，产生错误



使用 Go 的两个重要的环境变量

$GOROOT
这个环境变量定义了 Go 的安装路径目录
若是默认安装，可不定义

$GOPATH
这个环境变量定义了 编写代码 的工作路径
需要指定，以方便工作



编译 Go 程序
命令行输入
go build helloworld.go
接着运行
./helloworld



声明变量

eg1:
var a int
a = 1

eg2:
var a int = 2

eg3:
a := true

eg4:
var (
	a int
	b int = 2
)

eg5:
var a,b int

eg6:
a,b := 1,true


eg1 中
var 是关键字表示该行将声明一个变量
a 是变量名
int 是变量 a 的类型
此时 a 的值为 0
a = 1 则是为 a 赋值为 1

eg2 中
变量的声明和赋值可以简写为一行

eg3 中
用 := 快速声明一个变量
此时变量类型会自动判断
这种快速声明的方式只能出现在函数代码块中

eg4 中
可以使用 var(...) 的形式快速声明多个变量
同时也接受声明变量同时赋值

eg5 中
若变量具有相同的类型
可以用这个方法简便声明

eg6 中
也可这样在同一行中
声明不同类型的变量



变量的赋值

var(
	a int
	b bool
)

eg1:
a,b = 1,true

eg2:
_,b = 1,true


eg1 中
类似变量的声明
可以这样赋值

eg2 中
可以用下划线 _ 舍去一个变量值
这样 1 这个值被舍去了
而 true 被赋予了变量 b


注意，所有声明的变量都必须被使用
否则编译时会报错



常见数据类型

1、布尔类型 bool
布尔类型的值仅为 true 和 false
不包含 0 1 空集 等等


2、数字类型

int 根据所在系统的构架自动选择 32 位或是 64 位
uint 无符号的 int 类型
int8 int16 int32(rune) int64
byte(uint8) uint16 uint32 uint64

注意1 byte 是 uint8 的别名
	  rune 是 int32 的别名
	  * rune 的英文含义是：如尼文，神秘的
注意2 上述的 10 中类型是完全不同的十种类型
	  不可以混用，需要显事转换
	  也就是说 int 和 int64 即使在 64 位的系统上
	  也是完全不同的类型

float32 float64

注意 没有 float 浮点型 这个类型

最后 即使在 32 位的系统上 64 位的类型依旧是 64 位的


3、常量 （这不是一种数据类型）

常量用关键字 const 来定义
定义常量时，可以指明类型，也可以不指明类型

const (
	a int = 5
	b = bool
)

常量的值和类型可以承前省略

const (
	a = 5
	b			// b 为 int 型 值为 5
	c			// c 同 b
	d = true
	e			// e 为 bool 型 值为 true
	f			// f 同 e
)

对于未声明类型的整型常量，可以使用 iota 预声明标记 来表示续递增的整型常量

const (
	a = iota	// a int = 0
	b			// b = iota --> b int = 1
	c			// c = iota --> c int = 2
)

iota 永远从 const 声明之后就开始计数，直到遇见下一个 const
但仅有继承了 iota 的值会显示 iota 表示的值

const (
	a = 6		// 手动指定
	b = iota	// b 是这组常量的第二个 --> b int = 1
	c			// c = iota --> c int = 2
	d = false	// 手动指定
	e			// e 同 d 类型为 bool 值为 false
	f = iota	// f 是这组常量的第六个 --> f int = 5
	g			// g = iota --> g int = 6
	h			// h = iota --> h int 7
)

* iota 源自希腊字母 ι 读作 yota 表示微小之物

注意 所有的常量必须具有明确且固定的值
	这个值可以来自于一个常量、承前省略或者 iota
	但不可以来自一个变量、函数的返回值等等


4、字符串 string

eg1:
s1 := "Hello, 世界！"
s2 := `Hello
	世界！`			// 注意这里写的是反引号

eg1 中
字符串类型 只能用 双引号 或 反引号 引起来
不可以使用 单引号 引起来
双引号 表示 其中字符 可以转义
反引号 表示 其中字符 不可转义（raw 字符串）
单引号 表示 仅含有一个 Unicode 字符

eg2:
s := "中文字符串"
b := s[0]				// 这样是无法取出 中 字的
fmt.Println(b)			// 会打印出 228

eg2 中
字符串在 Go 中以连续的 UTF-8 格式保存
如果直接使用 切片 取值，则 Go 会以 1 byte 作为长度切片
比如上述案例会打印出 228，转化为 16 进制则为 e4
也就是 中 这个字的 UTF-8 编码 \xe4\xb8\xad 的第一位

eg3:
s1 := "Starting Part"
	+ "Ending Part"		// 这样的两行文字会提示错误

s2 := "Starting Part" +
	"Ending Part"		// 这样的两行文字则不会提示错误

eg3 中
参加 Go 行尾加分号 的问题

eg4:
s1 := "世界"							// 字符表示
s2 := "\u4e16\u754c"				// 四位 Unicode 表示
s3 := "\U00004e16\U0000754c"		// 八位 Unicode 表示
s4 := "\xe4\xb8\x96\xe7\x95\x8c"	// 16 进制 UTF-8 表示

eg4 中
上述三种方法都可以表示 Unicode 字符


由于 UTF-8 是变长编码，所以需要一种类型将 UTF-8 解码为 Unicode 编号
这种类型在 Go 中被称为 rune （实际上存储的是 int32）


5、rune

eg1:
var s string = "英文字符"	// 原始字符
var c []rune = []rune(s)	// 转换为 rune 切片（也可以转化为 int32 切片）
c[0] = '中'					// 修改第一个切片，注意使用了单引号
fmt.Println(string(c))		// 打印 rune 切片 c，并通过 string 转化为字符串

eg1
正确的“修改”字符串的方法


6、复数

complex128	具有 64 位实部和 64 位虚部的复数
complex64	具有 32 位实部和 32 位虚部的复数

eg1:
var cp1 complex128 = 1.2+5.3i

注意1 复数的虚部不为 0 一定要写成 <num>i 的形式
	  不可以写成 1.2+i 或者 1.2+1*i
	  会与 i 是一个变量混淆

注意2 若使用简便声明复数，即便虚部为 0 也要写出虚部来
	  否则会被判定为一个实数

7、错误

eg1:
var e error = nil

eg1 中
定义了一个 error 类型的 e 变量，实际上 error 类型是一个接口
