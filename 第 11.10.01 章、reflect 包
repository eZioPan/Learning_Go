reflect 包实现了运行时反射，允许一个程序操控各种类型的对象
常见用法即为：从静态类型 interface{} 中取出一个值，并通过调用 TypeOf，返回一个 Type 类型的值，来获得它的动态类型信息
调用 ValueOf 返回一个 Value 类型的数据，表示运行时数据
Zero 函数获取一个 Type 类型的值，并返回一个代表该类型零值的 Value 类型的值

参见 “The Laws if Reflection” 了解 Go 语言中 reflection 的简介
https://golang.org/doc/articles/laws_of_reflection.html



Copy(dst, src Value) int
将 src 的内容开呗值 dst 中，直到 dst 被填满或者 src 被耗尽
返回拷贝元素的数量
dst 和 src 必须具有 Slice 或 Array 的 kind
且 dst 和 src 必须具有相同的元素类型


DeepEqual(x,y interface{}) bool
返回 x 和 y 是否 “深层相等”
若两个相同类型的值满足以下条件之一，则称之为 “深层相等” 的

<1> Array 值：当它们所含有的元素一一对应 “深层相等” 时

<2> Struct 值：当它们所含字段一一对应 “深层相等” 时（包含导出字段和非导出字段）

<3> Func 值：当它们均为 nil 时，它们 “深层相等”，否则它们 不为 “深层相等”

<4> Interface 值：当它们具有的值 “深层相等” 时，它们 “深层相等”

<5> Map 值：当符合以下全部规则时，它们 “深层相等”
	1. 它们要么全部是 nil，要么全部是 非 nil
	2. 它们具有相同的长度
	3. 它们要么是完全相同的 map 对象，要么对应键名对应的值是 “深层相等” 的

<6> Pointer 值：要么用 Go 操作符 == 返回值为真，要么指向 “深层相等” 的值

<7> Slice 值：当符合以下全部规则时，它们 “深层相等”
	1. 它们要么全部是 nil，要么全部是 非 nil
	2. 它们具有相同的长度
	3. 它们要么指向完全相同的底层 array 的相同条目，要么一一对应的所有元素都是 “深层相等” 的
	注意： 非 nil 空 slice 和 nil slice 是 非 “深层相等” 的
		eg. []byte{} []byte{nil} 是不同的

<8> 其他值 —— 数字、布尔值、字符串、通道 —— 若它们被 Go 操作符 == 返回真，则为 “深层相等”

大体来说， DeepEqual 就是递归进行 Go 操作符 == 操作
但这个想法和实际必有一些出入
特别的，
有一些值可能和自身不相等，比如 func 值（不可比较的类型）或者 浮点数的 NaN 值（在浮点比较中不相等）
或者 含有上述两种值的 array struct 与 interface
另一方面， pointer 永远与自身相等，即便它们指向了上述两种值，
因为无论它们的内容如何，pointer 总会在 Go 操作符 == 下与自身相等
DeepEqual 函数被设计成为只要 slice 和 map 是完全相同的 slice 和 map，无论内容也会 “深度相等” 的状态


Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)
选择执行被 cases 所描述的一系列操作中的一个
如同 Go 的 select 声明，它会阻塞，直到至少一个 case 可以被执行，做一个均一化随机选择，并执行那个 case
它返回被选中 case 的索引号，若 case 是一个拉取操作，拉取的值被返回，
并且返回一个布尔值，指示出该值是否真的是 send 出来的数据（反例：由于通道关闭，所以接受到一个零值）


Swapper(slice interface{}) func(i, j int)
返回一个翻转输入 slice 的函数
若输入并非 slice 类型，Swapper panic


ChanDir int 类型

表示 channel 类型的方向

const(
	RecvDir ChanDir = 1 << iota	// <-chan
	SendDir						// chan<-
	BothDir = RecvDir | SendDir	// chan
)


(d ChanDir) String() string
满足了 fmt.Stringer 接口



Kind uint 类型

表示了 Type 类型所表示的特定类型
Kind 的零值不是一个合法的 kind

const (
	Invalid Kind = iota
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr
	Float32
	Float64
	Complex64
	Complex128
	Array
	Chan
	Func
	Interface
	Map
	Ptr
	Slice
	String
	Struct
	UnsafePointer
)

(k Kind) String() string
满足了 fmt.Stringer 接口



Method struct 类型

代表了一个单独的方法

type Method struct {
	// Name 即为方法的名称
	// PkgPath 即为小写方法名（非导出方法）的包路径
	// 对于大写方法名（导出方法），PkgPath 为空
	// Name 和 PkgPath 从一个方法集中确定了一个唯一的方法
	// 参见 https://golang.org/ref/spec#Uniqueness_of_identifiers
	Name    string
	PkgPath string

	Type  Type  // 方法的类型
	Func  Value // 以接受者为第一个参数的函数
	Index int   // Type.Method 的索引
}



SelectCase struct 类型

一个 SelectCase 描述了正在一个选择操作中的一个单一的 case
case 的 kind 由 Dir，也就是 通信的方向 决定

若 Dir 为 SelectDefault，case 表示了一个默认 case
Chan 和 Send 必须为 zero Value

若 Dir 为  SelectSend，case 表示了一个发送 case
普通情况下， Chan 的底层值必须是 channel，Send 的底层值必须是 channel 可以接受的元素类型
特殊情况，若 Chan 是 ezro Value，那么 case 被忽略， Send 也同样被忽略，此时可以为 zero 或 non-zero

若 Dir 为 SelectRecv，case 表示了一个接受 case
通常情况下，Chan 的底层值必须是是 channel，Send 的底层值必须是 channel 可以接受的元素类型
若 Chan 是 zero Value，那么 case 将被忽略，但 Send 依旧必须为 zero Value
当接收操作被选中， Value 的值就被 Select 函数返回

type SelectCase struct {
	Dir  SelectDir // case 的方向
	Chan Value     // 使用的 channel（发送或接接收）
	Send Value     // 将要发送的值（发送时使用）
}



SelectDir int 类型

描述了一个 select 的 case 的通信方向

const (
	SelectSend SelectDir    // case Chan<- Send
	SelectRecv              // case <-Chan
	SelectDefault           // default
)



SliceHeader struct 类型

运行时 slice 的表现
该类型会随着语言的更新而变动
Data 字段也无法有效保证被它引用的数据不被垃圾回收清理，
所以程序必须持有一个独立且正确的具有类型的指针来指向底层数据

type SliceHeader strcut{
	Data uintptr
	Len int
	Cap int
}



StringHeader struct 类型

运行时 string 的表现
该类型会随着语言的更新而变动
Data 字段也无法有效保证被它引用的数据不被垃圾回收清理，
所以程序必须持有一个独立且正确的具有类型的指针来指向底层数据

type StringHeader struct {
	Data uintptr
	Len  int
}



StructFiled struct 类型

描述了一个结构体中的单一的一个字段

type StructField struct {
	// Name 为字段名
	Name string
	// PkgPath 使用包路径定位了一个小写（非导出）字段名
	// 对于大写（导出）字段名，该位置为空
	// 参见 https://golang.org/ref/spec#Uniqueness_of_identifiers
	PkgPath string

	Type      Type      // 字段类型
	Tag       StructTag // 字段标签字符串
	Offset    uintptr   // byte 为标记的字段相对所在结构体的偏移值
	Index     []int     // Type.FieldByIndex 的索引
	Anonymous bool      // 内嵌字段
}



StructTag string 类型

结构体类型的 标签字符串

为了方便，标签字符串 由 空格分开的 键:"值" 对组成
每个 tag 键都由不含控制符、空格、双引号、冒号的非空字符串构成
每个 tag 值 都由双引号引起，并遵循 Go 字符串的语法


(tag StructTag) Get(key string) string
该方法返回与 tag 键 对应的 tag 值
若没有对应的 tag 键，则返回空字符串
若 tag 不具有常规的格式，则本方法的返回值不可预知
若要明确一个 tag 是否明确被设置为空字符串，使用 Lookup 方法


(tag StructTag) Lookup( key string) (value string, ok bool)
该方法返回 tag 键 对应的 tag 值
若 tag 中存在对应的 tag 键，则返回其值（即便可能是空值）
ok 返回一个 tag 值 是否明确的被设定了
若 tag 不具有常规的格式，则本方法的返回值不可预知



Type interface 类型

该类型表示 Go 的一种类型

并非所有的方法都适用于所有的类型
若有限制，则标注在每个方法的文档中
在调用 每 kind 特定的 方法中，用 Kind 方法找出类型的 kind
对某一 kind 的 类型 调用了不合适的方法，将导致 运行时错误

Type 类型的值是可以比较的，比如使用 == 操作符
若两个 Type 值表示相同的 类型，则它们两者相等

type Type interface {

	// 返回以 字节 为单位计算的这种类型的值，在内存中的对齐值
	Align() int

	// 返回，当该类型的值作为 结构体中的一个字段时，
	// 以 字节 为单位计算的这种类型的值，在内存中的对齐值
	FieldAlign() int

	// 返回该类型的方法集的第 i 个方法
	// 若 i 不在范围 [ 0, NumMethod() ) 中时，引发 panic
	//
	// 对于 非接口类型 T 或 *T，返回的 Method 类型的值的 Type 字段 和 Func 字段
	// 描述了一个首个参数为接受者的函数
	//
	// 对于一个 接口类型，返回的 Method 类型的值的 Type 字段 给出了方法的签名
	// 该方法并不含有接受者，且 Func 字段为 nil
	Method(int) Method

	// 返回 指定类型的 方法集 中，具有该 方法名 的方法
	// 并用一个 布尔值 表示该方法是否被找到
	//
	// 对于 非接口类型 T 或 *T，返回的 Method 类型的值的 Type 字段 和 Func 字段
	// 描述了一个首个参数为接受者的函数
	//
	// 对于一个 接口类型，返回的 Method 类型的值的 Type 字段 给出了方法的签名
	// 该方法并不含有接受者，且 Func 字段为 nil
	MethodByName(string) (Method, bool)

	// 返回指定类型的 方法集中 导出的方法的数量
	NumMethod() int

	// 返回指定类型 在它所在包内的 类型名
	// 对于未命名类型，会返回空字符串
	Name() string

	// 返回一个命名过的类型的 包路径
	// 也就是确定该包唯一位置的 导入路径，比如 "encoding/base64"
	// 若类型是 预声明的（比如 string 和 error） 或者 未命名的（比如 *T struct{} 和 []int）
	// 则 包路径 为空字符串
	PkgPath() string

	// 返回要存储一个指定类型的值，需要多少字节的存储空间
	// 与 unsafe.Sizeof 函数相似
	Size() uintptr

	// 返回用字符串表示的类型
	// 字符串可能会使用短包名称（比如说：使用 base64 而非 encoding/base64）
	// 因此不能保证在不同类型之间的唯一性
	// 测试类型的身份，请直接比较 Type 值
	String() string

	// 返回这个类型的 kind
	Kind() Kind

	// 报告这个类型是否实现了接口类型 u
	Implements(u Type) bool

	// 报告该类型的值是否可以被赋予至 类型 u 中
	AssignableTo(u Type) bool

	// 报告该类型的值是否可以被转换为 类型 u
	ConvertibleTo(u Type) bool

	// 报告该类型的值之间是否可以做比较
	Comparable() bool

	// 返回以 位 为单位计算的类型的大小
	// 若类型的 Kind 并非 sized 或 unsized 的 Int Uint Float Complex 类中的任何一个
	// 则产生 panic
	Bits() int

	// ChanDir returns a channel type's direction.
	// It panics if the type's Kind is not Chan.
	// 返回一个 通道 类型的方向
	// 若 类型的 Kind 值不是 Chan，则产生 panic
	ChanDir() ChanDir

	// 报告一个函数类型的输入形参的最后一个参数是否为 "..."
	// 若是如此，则 t.In(t.NumIn() - 1) 返回参数隐含的实际类型 []T
	//
	// 具体来说，若 t 代表了 func(x int, y ... float64)， 那么
	//
	// t.NumIn() == 2
	// t.In(0) 是 “int” 的 reflect.Type
	// t.In(1) 是 “[]float64” 的 reflect.Type
	//
	// 若方法接受者的类型的 Kind 并非 Func，则产生 panic
	IsVariadic() bool
}
