并发（Concurrent） 与 并行（Parallel）

并发，指的是一个程序被设计为，可以同时启动多个独立控制流程的模式
	 在这种设计模式下，会出现多条控制流程
	 而程序可以掌握控每个制流程的启动、运行、暂停、切换、结束等等状态
	 并发并不意味着在同一个时间点上，有多个控制流程正在执行

并行，指在同一个时间，的确有超过一个以上的控制流程被执行

可以说，并发是并行的基础，但并发不代表并行



Go 语言通过 goroutine 来执行并发

goroutine 的简单定义
goroutine 是与其他 goroutine 相对独立执行，且处在相同的地址空间的函数

goroutine 是一个函数，它以关键字 go 作为开头

EG.
ready("Tea",2)		// 普通的函数调用
go ready("Tea",2)	// 作为 goroutine 执行



一个简单的并发例子：

EG:
// 本包通过 gotoutine 打印 0 至 50 这 51 个数字
package main

import (
	"fmt"
	"strconv"
)

// 定义一个要在 goroutine 中执行的函数
func span(w string) {
	fmt.Printf("%#v", w)
}

func main() {
	for i := 0; i <= 50; i++ {
		go span(strconv.FormatInt(int64(i), 10))	// 使用关键字 Go 启动一个 goroutine
	}
}


我们可以发现
1、程序是乱序打印数字的，说明 go 关键字的确成功造成了并发的效果
2、需要打印的数字的个数远远小于应该打印的个数
   这是因为 main 函数在其他 goroutine 还没有全部返回的时候就结束运行了
   于是没有运行完的 goroutine 就被立刻中断了


改进的并发例子：

EG2.【手动让 main 函数等待 goroutine 执行完毕】

// 本包通过 goroutine 打印 0 至 50 这 51 个数字
// 并手动使主程序等待 goroutine 返回
package main

import (
	"fmt"
	"strconv"
	"time"
)

// 定义一个要在 goroutine 中执行的函数
func span(w string) {
	fmt.Printf("%#v", w)
}

func main() {
	for i := 0; i <= 50; i++ {
		go span(strconv.FormatInt(int64(i), 10)) // 使用关键字 Go 启动一个 goroutine
	}
	time.Sleep(3 * time.Second) // 手动让 main 函数等待一段时间
}


这次所有 goroutine 的返回值都收到了


但是在绝大多数并行程序中，我们并不知道 goroutine 会运行多久
所以手动让 main 函数等待的做法并不可取



在 go 语言中，goroutine 之间通过一种内置类型的实例进行数据传递（通信）
这种内置的类型被称为 channel，每个 channel 如同一个可以带有中转功能的管道双向管道

对于不带有中转功能的 channel
仅当 channel 的发送端准备好发送数据，且接受端准备好接受数据时
channel 才会建立起来，并完成数据的传输
否则 发送端/接收端 所在的 goroutine 会进入睡眠状态，直到 channel 成功完成传输

对于带有中转功能的 channel
channel 可以存储一些数据在 channel 中
直到它们被拉取时，才会输出出来，并释该数据占用 channel 的空间
channel 中的数据遵循 FIFO 规则
当某个 channel 中充满的数据，则该 发送端/接收端 所在的 goroutine 就会进入睡眠状态
直到 channel 中的数据被拉取之后才解锁

若一个程序中，所有的 goroutine 都进入睡眠状态的时候
程序就会陷入 dead lock 状态，此时程序就会直接退出

也就是说，channel 本身是一种可以阻塞 goroutine 的



channel 的类型

chan <数据类型>

EG.
var ch1 chan int		// 传递 int 类型数据的 channel
var ch2 chan string		// 传递 string 类型数据的 channel
var ch3 chan []byte		// 传递 []byte 类型数据的 channel


除了普通的双向 channel
还有两种特殊的 channel
它们称为 one-derection channel
分别写为
<-chan <数据类型> 和 chan<- <数据类型>
常用于 函数的形式参数，不常用于直接创建



channel 的初始化
一个 channel 必须经过 make 语句的初始化之后，才能进行使用

EG.

// 创建一个传递 int 类型的无缓冲 channel
var ch1 chan int = make(chan int)
// 创建一个传递 string 类型的，具有一个缓冲位的 channel
var ch2 chan string = make(chan string,1)

注意，channel 被初始化以后，channel 变量中存储的是 channel 的内存地址
也就是说，不需要，也不可以 对 channel 取内存地址
