总览

flate 包实现了 DEFLATE 压缩数据格式，在 RFC 1951 中描述
gzip 和 zlib 包实现了存取基于 DEFALTE 的文件格式


EG.【Dictionary】

一个预设的字典可以用于提升压缩率
使用字典的缺点就是压缩器和解压器必须提前了解使用了何种字典

// 字典是一个用 byte 表示的字符串
// 当压缩一些输入的数据时，压缩器将尝试将子字符串替换为字典中匹配上的
// 这样来说，字典中的子字符串，应该仅为，会出现在实际数据流中的子字符串
const dict = `<?xml version="1.0"?>` + `<book>` + `<data>` + `<meta name="` + `" content="`

// 要压缩的数据应该（但不要求）频繁包含一些字符串，它们能与字典中的匹配上
const data = `<?xml version="1.0"?>
<book>
	<meta name="title" content="The Go Programming Language"/>
	<meta name="authors" content="Alan Donovan and Brian Kernighan"/>
	<meta name="published" content="2015-10-26"/>
	<meta name="isbn" content="978-0134190440"/>
	<data>...</data>
</book>
`

var b bytes.Buffer

// 使用特制的字典压缩数据
zw, err := flate.NewWriterDict(&b, flate.DefaultCompression, []byte(dict))
if err != nil {
	log.Fatal(err)
}
if _, err := io.Copy(zw, strings.NewReader(data)); err != nil {
	log.Fatal(err)
}
if err := zw.Close(); err != nil {
	log.Fatal(err)
}

// 解压器必须使用与压缩器相同的字典
// 否则输入就会像毁坏了一样
fmt.Println("Decompressed output using the dictionary:")
zr := flate.NewReaderDict(bytes.NewReader(b.Bytes()), []byte(dict))
if _, err := io.Copy(os.Stdout, zr); err != nil {
	log.Fatal(err)
}
if err := zr.Close(); err != nil {
	log.Fatal(err)
}

fmt.Println()

// 将字典中出现的字节全部用 '#' 来代替，来可视化展现使用预设字典的大致效果
fmt.Println("Substrings matched by the dictionary are marked with #:")
hashDict := []byte(dict)
for i := range hashDict {
	hashDict[i] = '#'
}
zr = flate.NewReaderDict(&b, hashDict)
if _, err := io.Copy(os.Stdout, zr); err != nil {
	log.Fatal(err)
}
if err := zr.Close(); err != nil {
	log.Fatal(err)
}


EG.【Reset】

在对性能有严格要求的应用中，Reset 可以用于取消当前的压缩/解压状态，并使用先前分配的内存来快速重新初始化它们

proverbs := []string{
	"Don't communicate by sharing memory, share memory by communicating.\n",
	"Concurrency is not parallelism.\n",
	"The bigger the interface, the weaker the abstraction.\n",
	"Documentation is for users.\n",
}

var r strings.Reader
var b bytes.Buffer
buf := make([]byte, 32<<10)

zw, err := flate.NewWriter(nil, flate.DefaultCompression)
if err != nil {
	log.Fatal(err)
}
zr := flate.NewReader(nil)

for _, s := range proverbs {
	r.Reset(s)
	b.Reset()

	// 重置压缩器，并从输入流中编码
	zw.Reset(&b)
	if _, err := io.CopyBuffer(zw, &r, buf); err != nil {
		log.Fatal(err)
	}
	if err := zw.Close(); err != nil {
		log.Fatal(err)
	}

	// 重置压缩器，并解码至输出流中
	if err := zr.(flate.Resetter).Reset(&b, nil); err != nil {
		log.Fatal(err)
	}
	if _, err := io.CopyBuffer(os.Stdout, zr, buf); err != nil {
		log.Fatal(err)
	}
	if err := zr.Close(); err != nil {
		log.Fatal(err)
	}
}


EG.【同步】

DEFLATE 适用于通过网络传输压缩过的数据

var wg sync.WaitGroup
defer wg.Wait()

// 使用 io.Pipe 来模拟一个网络连接
// 现实中的网络应用应该小心而正确地关闭底层连接
rp, wp := io.Pipe()

// 启动一个 goroutine 来饰演发送端
wg.Add(1)
go func() {
	defer wg.Done()

	zw, err := flate.NewWriter(wp, flate.BestSpeed)
	if err != nil {
		log.Fatal(err)
	}

	b := make([]byte, 256)
	for _, m := range strings.Fields("A long time ago in a galaxy far, far away...") {
		// 我们使用简单的帧格式
		// 第一个字节是信息的长度，接着是内容本身
		b[0] = uint8(copy(b[1:], m))

		if _, err := zw.Write(b[:1+len(m)]); err != nil {
			log.Fatal(err)
		}

		// Flush 保证了接收端能接收到到目前为止所有的数据
		if err := zw.Flush(); err != nil {
			log.Fatal(err)
		}
	}

	if err := zw.Close(); err != nil {
		log.Fatal(err)
	}
}()

// 启动一个 goroutine 来饰演接收端
wg.Add(1)
go func() {
	defer wg.Done()

	zr := flate.NewReader(rp)

	b := make([]byte, 256)
	for {
		// 读取信息长度
		// 用于保证对发送端的每个 Flush 和 Close 都返回
		if _, err := io.ReadFull(zr, b[:1]); err != nil {
			if err == io.EOF {
				break // 发送端关闭了流
			}
			log.Fatal(err)
		}

		// 读取信息内容
		n := int(b[0])
		if _, err := io.ReadFull(zr, b[:n]); err != nil {
			log.Fatal(err)
		}

		fmt.Printf("Received %d bytes: %s\n", n, b[:n])
	}
	fmt.Println()

	if err := zr.Close(); err != nil {
		log.Fatal(err)
	}
}()
