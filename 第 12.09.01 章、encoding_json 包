json 包实现了编码和解码 JSON 文件的方法
JSON 类型与 Go 类型的对应关系在 Marshal 和 Unmarshal 函数中说明



Compact(dst *bytes.Buffer, src []byte) error
将 JSON 编码过的字节流，去掉无用的空白字符，并追加至目标 Buffer 的尾部


HTMLEscape(des *bytes.Buffer, src []byte)
将 JSON 中出现的 HTML 特殊字符都转义为非特殊字符


Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
向目标 Buffer 尾部追加 缩进过的 JSON 数据
每个 JSON 元素都放在新的一行中，且这行的行首追加 prefix 定义的字符串，缩进将使用 indent 定义的字符串
原 JSON 中行首的 空白字符都会被省略，但行尾的都会被保留


Marshal(v interface{}) ([]byte, error)
Marshal 函数返回 JSON 编码的 数据 v，（Marshal 在英语中有编队的含义）

Marshal 会递归扫描 v 的值。如果遇到的值实现了 Marshaler 接口，并且不为 nil 指针，则 Marshal 调用该值的 MarshalJSON 方法来产生 JSON 数据
若没有实现 MarshalJSON 方法，但实现了 encoding.TextMarshaler,则 Marshal 调用 MarshalText 方法来产生 JSON 字符串
nil 指针 exception 并非严格需要，而是对 UnmarshalJSON 行为的一种模仿

其他情况下， Marshal 遵循下列 类型相关 默认编码：

布尔值 编码为 JSON 布尔值

浮点数、整数、 Number 值 编码为 JSON 数字

字符串 编码为 JSON 字符串，并强制转换为合法 UTF-8 字符，将不合法字符传唤为 Unicode replacement rune
尖角括号 < 和 > 转义为 \u003c 和 \u003e，防止部分浏览器将 JSON 数据误认为 HTML 数据
& 符号 转义为 \u0026，同样为了防止浏览器误认
可以调用 Encoder 的 SetEscapeHTML(false) 方法来关闭该 Encoder 实例的转义功能

array 和 slice 编码为 JSON array
特例：
[]byte 转化为 base64 编码的字符串
nil slice 编码为 null JSON 值

结构体 编码为 JSON 对象
每个 导出的 结构体字段成为 JSON 对象的一个成员，字段名成为对象的键名
特例，在下列情况下，字段会被省略或被修改：
在结构体字段的标签（Tag）中，若含有 "json" 关键字，则 JSON 的键名可以被标签自定义
标签中，`json:` 后跟随的内容将作为键名，其后可能会跟随一些 逗号分隔 的选项列表
`json:` 后的名称可以被省略，而保留原始的键名，同时应用其后的选项列表
"omitempty" 选项表示，若字段为一个空值，则不将它编码，空值定义为: false、0、nil 指针、nil 接口值、空 array、空 slice、空 string
特别的，若字段标签仅为 "-"，则字段一直被忽略，若想输出键名为 "-" 的字段，可以使用 "-,"

注：使用反引号是因为标签中常出现单/双引号

EG.

// 该字段对应 JSON 的键名为 "myName"
Field int `json:"myName"`

// 该字段对应 JSON 的键名为 "myName"
// 若值为 JSON 的空值，则不导出这个字段
Field int `json:"myName,omitempty"`

// 该字段对应的 JSON 的键名即为字段名
// 若值为 JSON 的空值，则不导出这个字段
// 注意 omitempty 前序的逗号
Field int `json:",omitempty"`

// 不导出该值至 JSON
Field int `json:"-"`

// 该值的 JSON 键名为 "-"
Field int "-,"

"string" 选项表示该值在 JSON 中以 JSON 编码的字符串的形式保存
该选线仅能应用在 Go 的字符串类型、浮点类型、整数类型、布尔类型
常用于与 JS 程序互动的情况

EG.

Int64String int64 `json:",string"`

若字段名为仅含 Unicode 字符、数字、ASCII 标点符号（不含引号、反斜线、逗号）的非空字符
则可用于 JSON 键名的编写

匿名结构字段的 JSON 编码，一般按照内部可导出字段完全置于外部结构的做法，相对于 Go 的字段可见性的修正见下文
匿名字段使用 标有 json 的 tag 作为其 JSON 名称，而非在 JSON 中匿名
若匿名字段的类型为 interface，则用类型名作为该 interface 的 JSON 键名

Go 的结构体可见性规则，在执行 JSON 的 marshal 和 unmarshal 将会得到修正，以配合 JSON 的编码标准
若多重字段存在于同一级别，且该级别已经是最简嵌套，则增加以下规则：

<1> 对于重复字段，仅有被标有 json 的 tag 的字段会加入 编码考虑，忽略其他重复字段

<2> 若仅有一个字段被 JSON 标记，则选择该字段

<3> 除上述两条之外，若还有多个字段，则全部忽略，不产生错误

实测结果：
<1> 将结构体所有的字段名通过 “有 tag 读取 tag 内容，无 tag 读取字段名” 的方法都转化为键名
<2> 若顶层的键名和非顶层键名重名，则仅保留顶层键名
<3> 若均为同级的插入结构体的键名重复，则全部丢弃，仅保留键名不重复的部分

Map 被编码为 JSON 对象
map 的键必须是 字符串、整型或者实现了 encoding.TextMarshaler 的类型
map 的键将被排序，并按照下述规则编码为 JSON 对象

<1> 字符串可以直接使用
<2> 实现了 encoding.TextMarshaler 的全部编码
<3> 整型值转换为字符串

指针编码为指针所指向的值
空指针编码为 JSON 的 null 对象

Interface 编码为 interface 所包含的对象
空 interface 编码为 JSON 的 null 对象

Channel/复数/函数 不可以被编码为 JSON 对象
编码上述类型的值会返回 UnsupportedTypeError

由于 JSON 不可以表示循环数据结构，所以 Marshal 不处理它们
对 Marshal 传入 循环结构将导致无限递归
