总览
		gob 包管理 gob 组成的数据流——在一个 Encode（发送方） 和一个 Decoder（接受方）之间传输的二进制值。
		典型的用法是传输远程程序调用（RPC）的参数和结果，比如被包 “net/rpc” 所提供的内容。

		该实现将数据流中的每种数据类型都定义了一个自定义编号，且该方法在使用单一 Encoder 发送数据流时最为高效，因为分担了编译的开销。

	基础
		gob 流是自解释的。数据流中的每个数据项前都有其类型的说明，该说明表示为一小组预定义的类型。
		指针不会被传输，而传输它指向的内容；也就是说，数据会被平面化。
		Nil 指针不被允许，因为它们不含任何值。
		递归类型是没有问题的，但递归值（循环数据）会产生问题。这个状况可能会有所改观。

		要使用 gob，创建一个 Encoder 并提供一系列数据项，包含值或可解析为值的指针。
		Encoder 保证了所有的类型信息在使用前都被传输了。
		在接受端，一个 Decoder 从编码的数据流中检索值，并解包至他们的本地变量中。

	类型和值
		源和目标值/类型并不需要完全一一对应。
		对于 stuct，存在于原数据但在接收时缺失的字段（以名称区分）将会被忽略。
		存在于目标的变量但在发送段缺失时，也会被忽略。
		若在两者之中存在同名的字段，则它们的类型必须兼容。
		接收端和发送段都会进行必要的引用和解引用将 gob 和实际的 Go 值之间转换。
		举例来说，一个被规划为下述的 gob 类型，

		struct { A，B int }

		可以从下述 Go 类型中发送和接收：

		struct { A, B int }     // 完全一致
		*struct { A, B int }	// 对结构体的引用
		struct { *A, **B int }	// 对字段的引用
		struct { A, B int64 }	// 不同的实体值类型；见下方

		也可以被接受为下述这些：

		struct { A, B int }		// 完全一致
		struct { B, A int }		// 顺序无关；仅匹配字段
		struct { A, B, C int }	// 多余的字段 （C） 被忽略
		struct { B int }		// 缺失的字段 （A） 被忽略；数据被丢弃
		struct { B, C int }		// 缺失的字段 （A） 被忽略；多余的字段 （C） 被忽略

		接收至下述类型将产生一个解码错误：

		struct { A int; B uint }	// 修改了 B 的符号
		struct { A int; B float }	// 修改了 B 的类型
		struct { }					// 不含任何共同字段名
		struct { C, D int }			// 不含任何共同字段名
