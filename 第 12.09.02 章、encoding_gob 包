总览
		gob 包管理 gob 组成的数据流——在一个 Encode（发送方） 和一个 Decoder（接受方）之间传输的二进制值。
		典型的用法是传输远程程序调用（RPC）的参数和结果，比如被包 “net/rpc” 所提供的内容。

		该实现将数据流中的每种数据类型都定义了一个自定义编号，且该方法在使用单一 Encoder 发送数据流时最为高效，因为分担了编译的开销。

	基础
		gob 流是自解释的。数据流中的每个数据项前都有其类型的说明，该说明表示为一小组预定义的类型。
		指针不会被传输，而传输它指向的内容；也就是说，数据会被平面化。
		Nil 指针不被允许，因为它们不含任何值。
		递归类型是没有问题的，但递归值（循环数据）会产生问题。这个状况可能会有所改观。

		要使用 gob，创建一个 Encoder 并提供一系列数据项，包含值或可解析为值的指针。
		Encoder 保证了所有的类型信息在使用前都被传输了。
		在接受端，一个 Decoder 从编码的数据流中检索值，并解包至他们的本地变量中。

	类型和值
		源和目标值/类型并不需要完全一一对应。
		对于 stuct，存在于原数据但在接收时缺失的字段（以名称区分）将会被忽略。
		存在于目标的变量但在发送段缺失时，也会被忽略。
		若在两者之中存在同名的字段，则它们的类型必须兼容。
		接收端和发送段都会进行必要的引用和解引用将 gob 和实际的 Go 值之间转换。
		举例来说，一个被规划为下述的 gob 类型，

		struct { A，B int }

		可以从下述 Go 类型中发送和接收：

		struct { A, B int }     // 完全一致
		*struct { A, B int }	// 对结构体的引用
		struct { *A, **B int }	// 对字段的引用
		struct { A, B int64 }	// 不同的实体值类型；见下方

		也可以被接受为下述这些：

		struct { A, B int }		// 完全一致
		struct { B, A int }		// 顺序无关；仅匹配字段
		struct { A, B, C int }	// 多余的字段 （C） 被忽略
		struct { B int }		// 缺失的字段 （A） 被忽略；数据被丢弃
		struct { B, C int }		// 缺失的字段 （A） 被忽略；多余的字段 （C） 被忽略

		接收至下述类型将产生一个解码错误：

		struct { A int; B uint }	// 修改了 B 的符号
		struct { A int; B float }	// 修改了 B 的类型
		struct { }					// 不含任何共同字段名
		struct { C, D int }			// 不含任何共同字段名

		整数用两种方法传递：任意精度的符号整型和任意进度的无符号整型。
		在 gob 类型中，没有 int8 和 int16 等之间的区分；仅有代符号整型和无符号整型。
		如下方描述的，发送方以变长编码发送值；接收端接收值并将其存入目标变量。
		浮点数永远以 IEEE-754 64 比特进度发送（见下方）。

		符号整型可以被接收至任何符号整型变量中：int，int64 等；无符号整型可以被接收至任何无符号整型中；浮点数值可以被任何浮点数值接收。
		但是，目标变量必须具有表示该值的能力，否则解码操作也会失败。

		同样支持结构体、数组和切片。结构体仅会编码和解码导出字段。
		字符串和字节数组支持特定的高效表示方法（见下）。
		当一个切片解码时，若现存的切片容量足够，则扩展当前切片；若不够，则分配一个新的切片。
		无论如何，返回的切片的长度都报告了解码的元素的个数。

		通常来说，若需要执行分配，解码器将分配内存。若不需要，它将会从数据流中解码数据并更新目标变量。
		它不会预先初始化它们，所以，若目标是复合值，比如字典、结构体或切片，解码的值将在元素层级与原有变量融合。

		函数和通道将不通过 gob 传送。尝试在顶层编码该类值将失败。作为结构体字段的通道或者函数类型将作为非导出字段对待，会直接被忽略。

		gob 将以以下顺序选择编码方式：
			1、实现了 GobEncoder
			2、实现了 encoding.BinaryMarshaler
		且调用它们来实际执行编码

		gob 将以以下顺序选择解码方式：
			1、实现了 GobDecoder
			2、实现了 encoding.BinaryUnmarshaler
		且调用它们来实际执行编码

	编码细节
		这部分记录了编码过程，细节对于大多数用户来说都不重要。细节以由底至顶的样式呈现。

		一个无符号整数以两种方式中的一种发送。若它小于 128，则以单字节发送该值。
		除此之外它以最小长度的大端序（高位字节优先）字节流存储值，前序跟随一字节的字节长度计数的反码。
		因此 0 以 （00） 发送， 7 以 （07） 发送，256 以 （FE 01 00） 发送。

		布尔值以无符号整型编码发送：0 为 假，1 为 真。

		一个符号整型 i，被编码为一个无符号整型 u。在 u 中，bit 1 及以上的包含数据，bit 0 表示是否应该执行取补运算。
		编码算法看起来如下：

		var u uint
		if i < 0 {
			u = (^uint(i) << 1) | 1	// i 的补码，bit 0 为 1
		} else {
			u = uint(i) << 1		// 不执行取补码，bit 0 为 0
		}
		encodeUnsigned(u)

		因此，低位 bit 等同于一个符号 bit，但用于设置补码 bit，而非保证最大的负数不为特例。
		举例来说， -129=^128=(^256>>1) 编码为 （FE 01 01）

		浮点数永远以 float64 值表示传送。该值将会以 math.Float64bits 转换为 uint64。这个 uint64 值会进行字节逆序，并以普通无符号整型发送。
		字节逆序意味着指数和小数的高精度部分会先编码。这是由于低位 bit 通常为 0，这样可以节省编码字节。
		举例来说，17.0 仅用三字节即可编码 （FE 31 40）。

		字符串和字节切片将以无符号统计数，后接那么多字节的未解释数据。
		任何其他的切片和数组都表示为无符号统计数，后接那么多个元素，每个元素都递归地以它自己的标准 gob 编码表示。

		字典表示为无符号计数，后接那么多个键值对。空的但非 nil 的字典会被发送，所以若接收端并未分配一个，则永远会分配一个，除非发出的字典为 nil 且不在顶层。

		在切片、数组和字典中，所有元素，包括零值元素都会被发送，即便所有元素都是 0 也会被发送。

		结构体以一系列（字段号，字段值）数据对。字段值递归使用其类型的标准 gob 编码。
		若一个字段为其类型的零值，（除了数组，见上）则从传送中忽略。
		字段号由被编码的结构体的类型来定义：被编码的类型的第一个字段为字段 0，第二个为字段 1，等等。
		当编码一个值时，字段号出于效率以增量编号，而字段总是顺着字段号增加的顺序发送；增量因此是一个无符号整型。
		初始化增量编号时，设置字段号为 -1，所以一个值为 7 的无符号整数字段 0，将以 无符号增量 = 0，无符号值 = 7 或者（01 07） 来发送。
		最终，当所有的字段都被发送完毕时，将发送一个终止符，标示结构体的结束。这个标记时就是增量 = 0 的值，表示为 （00）。

		接口类型为了兼容性不会被查验；所有的接口类型在传输时，都被当成单个 “interface” 的成员，和 int 或 []byte 类似 —— 实际上他们都被当成 interface{} 对待。
		接口值以字符串定义的被发送的实际类型（必须通过调用 Register 预先定义一个名称），跟随 1 字节的其后数据长度（这样，若值无法被解析，就可以被跳过了），跟随保存在接口值中的通常编码的实际（动态）值。
		（一个 nil 接口由一个空字符串定义，且不传输任何值）在接收端，解码器会验证被解包的实际项目满足了接收变量的接口。
