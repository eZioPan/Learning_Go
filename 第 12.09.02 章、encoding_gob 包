总览
		gob 包管理 gob 组成的数据流——在一个 Encode（发送方） 和一个 Decoder（接受方）之间传输的二进制值。
		典型的用法是传输远程程序调用（RPC）的参数和结果，比如被包 “net/rpc” 所提供的内容。

		该实现将数据流中的每种数据类型都定义了一个自定义编号，且该方法在使用单一 Encoder 发送数据流时最为高效，因为分担了编译的开销。

	基础
		gob 流是自解释的。数据流中的每个数据项前都有其类型的说明，该说明表示为一小组预定义的类型。
		指针不会被传输，而传输它指向的内容；也就是说，数据会被平面化。
		Nil 指针不被允许，因为它们不含任何值。
		递归类型是没有问题的，但递归值（循环数据）会产生问题。这个状况可能会有所改观。

		要使用 gob，创建一个 Encoder 并提供一系列数据项，包含值或可解析为值的指针。
		Encoder 保证了所有的类型信息在使用前都被传输了。
		在接受端，一个 Decoder 从编码的数据流中检索值，并解包至他们的本地变量中。

	类型和值
		源和目标值/类型并不需要完全一一对应。
		对于 stuct，存在于原数据但在接收时缺失的字段（以名称区分）将会被忽略。
		存在于目标的变量但在发送段缺失时，也会被忽略。
		若在两者之中存在同名的字段，则它们的类型必须兼容。
		接收端和发送段都会进行必要的引用和解引用将 gob 和实际的 Go 值之间转换。
		举例来说，一个被规划为下述的 gob 类型，

		struct { A，B int }

		可以从下述 Go 类型中发送和接收：

		struct { A, B int }     // 完全一致
		*struct { A, B int }	// 对结构体的引用
		struct { *A, **B int }	// 对字段的引用
		struct { A, B int64 }	// 不同的实体值类型；见下方

		也可以被接受为下述这些：

		struct { A, B int }		// 完全一致
		struct { B, A int }		// 顺序无关；仅匹配字段
		struct { A, B, C int }	// 多余的字段 （C） 被忽略
		struct { B int }		// 缺失的字段 （A） 被忽略；数据被丢弃
		struct { B, C int }		// 缺失的字段 （A） 被忽略；多余的字段 （C） 被忽略

		接收至下述类型将产生一个解码错误：

		struct { A int; B uint }	// 修改了 B 的符号
		struct { A int; B float }	// 修改了 B 的类型
		struct { }					// 不含任何共同字段名
		struct { C, D int }			// 不含任何共同字段名

		整数用两种方法传递：任意精度的符号整型和任意进度的无符号整型。
		在 gob 类型中，没有 int8 和 int16 等之间的区分；仅有代符号整型和无符号整型。
		如下方描述的，发送方以变长编码发送值；接收端接收值并将其存入目标变量。
		浮点数永远以 IEEE-754 64 比特进度发送（见下方）。

		符号整型可以被接收至任何符号整型变量中：int，int64 等；无符号整型可以被接收至任何无符号整型中；浮点数值可以被任何浮点数值接收。
		但是，目标变量必须具有表示该值的能力，否则解码操作也会失败。

		同样支持结构体、数组和切片。结构体仅会编码和解码导出字段。
		字符串和字节数组支持特定的高效表示方法（见下）。
		当一个切片解码时，若现存的切片容量足够，则扩展当前切片；若不够，则分配一个新的切片。
		无论如何，返回的切片的长度都报告了解码的元素的个数。

		通常来说，若需要执行分配，解码器将分配内存。若不需要，它将会从数据流中解码数据并更新目标变量。
		它不会预先初始化它们，所以，若目标是复合值，比如字典、结构体或切片，解码的值将在元素层级与原有变量融合。

		函数和通道将不通过 gob 传送。尝试在顶层编码该类值将失败。作为结构体字段的通道或者函数类型将作为非导出字段对待，会直接被忽略。

		gob 将以以下顺序选择编码方式：
			1、实现了 GobEncoder
			2、实现了 encoding.BinaryMarshaler
		且调用它们来实际执行编码

		gob 将以以下顺序选择解码方式：
			1、实现了 GobDecoder
			2、实现了 encoding.BinaryUnmarshaler
		且调用它们来实际执行编码
