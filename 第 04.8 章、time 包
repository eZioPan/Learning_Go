time 包
测量和显示时间


全局常数

时间显示格式

time 包可以用一个字符串来表示显示时间所用的模板
这个时间是一个固定的值：

Mon Jan 15:04:05 MST 2006

这个值常用于 time.Format(<format>) 和 time.Parse(<format>)
可以用这个时间点来自定义自己表示时间的方式
EG.
// 获取当前时分秒
time.Now().Format("15:04:05")
// 解释输入的小时和分钟，并附加上时区
time.Parse("15:04 Z07", "10:30 +08")

注意 time.Now().Format("Mon Jan _2") 中的下划线，表示日期若不足两位，则在日期前补 0

Go 预设了一系列字符串作为格式化时间的标准模板，它们就在 time 包的全局常量中
常用的有
time.ANSIC time.UnixDate time.Kiten time.Stamp time.Milli time.StampNano



time.After(d time.Duration) <-chan time.Time
用于 select 语句，置于 case 中，作为 select 的超时处理机制
time.After 会在指定的时间之后向 select 中传递数据，结束 select 的轮询


time.Sleep(d time.Duration)
将所在的进程暂停至少 d 的时间
若 d <= 0 则 time.Sleep 会立刻返回


time.Tick(d time.Duration) <-chan time.Time
对 time.NewTicker 的简化包装，仅返回 tick channel
time.Tick 在指定的时间间隔不断的产生当前时间的返回值
time.Tick 不会自我关闭，其底层的 time.NewTicker 会一直执行
所以需要其他方法来关闭



time.Duration int64 类型

time.Duration 类型用 int64 数据表示了两个时间点之间的间隔的纳秒数
最大可用间隔大约为 290 年

该类型的常量有
Nanosecond Microsecond Millisecond Second Minute Hour


time.ParseDuration(s string) (Duration, error)
将字符串表示的时间差转化为 time.Duration 表示的时间差
可接受的单位有 ns us(µs) ms s m h
字符串中可以出现小数


time.Since(t Time) Duration
time.Until(t Time) Duration
过去的时间距今的时间差，以及未来的时间距今的时间差
分别是 time.Now().Sub(t) 和 t.Sub(time.Now()) 的缩写


(time.Duration) Hours() float64
(time.Duration) Minutes() float64
(time.Duration) Seconds() float64
(time.Duration) Nanoseconds() int64
(time.Duration) String() string
将时间差转化为 小时数、分钟数、秒数、纳秒数、以及字符串
其中 小时数、分钟数、秒数 均为 64位浮点数
纳秒数为 64位整型
字符串总保证使用了首位非零的最大单位
	若时间差大于 1s 则最小单位为秒，且秒可能出现小数
	若时间差小于 1s 则最小单位自动取其他小单位
	若时间差为 0 则返回 0s



time.Location struct 类型

time.Location 将时间映射至当前所在地点的时间

time.FixedZone(name string, offset int) *Location
新建一个地点，使用制定的名称和相对 UTC 时间偏移的秒数

time.LoadLocation(name string) (*Location, error)
通过地点名称获取 time.Location 类型的数据
若地点名为 "" 或 "UTC" 则返回 UTC
若地点名为 "Local" 则返回 Local
其他地点，则参照 IANA 时区数据库，表示为 "Asia/Shanghai"
Go 自带支持的数据库可查看
$GOROOT/lib/time/zoneinfo.zip


(l *time.Location) String() string
用于实现 fmt.Stringer 接口



time.Month int 类型
定义了英文中月份的表示


(time.Month) String() string
用于实现 fmt.Stringer 接口



time.ParseError struct 类型
定义了一系列解析错误


(e *time.ParseError) Error() string
用于实现 builtin.error 接口



time.Ticker struct 类型
具有一个可提供时钟滴答的 out channel


NewTicker(d Duration) *Ticker
返回一个以 d 为时间间隔的 time.Ticker
对于较慢的接收者，它会调整间隔或者丢弃一些 时钟滴答
d 必须大于 0，否则会产生 panic
停止一个 ticker，来释放相关的资源


(*time.Ticker) Stop()
停止向 channel 中传入 ticker
但并不会关闭这个 channel
防止后续读取出现错误



time.Time struct 类型

纳秒精度的时间表示
一般来说，应该使用这个类型的值，而非指针

这个类型的 相互比较 可以使用方法 Before After Equal
这个类型的相减方法为 Sub，两个 Time 类型相减，返回一个 time.Duration 类型
这个类型的相加方法为 Add，一个 time.Time 类型 Add 一个 time.Duration 类型，得到一个 time.Time 类型

这个类型的零值为 Jan 1st 00:00:00.000000000 UTC
可以用 IsZero 判断该类型的变量是否被初始化

一个 time.Time 类型总是与一个 time.Location 类型相关联
改变一个 time.Time 的 Location 仅改变了该 time.Time 的展现方式，不改变实际内容

注意，Go 语言中的 == 操作，会同时比较 time.Time 和 time.Location
所以，time.Time 被用作 map 和 数据库 的 键 时，必须要转换至同一个时区


time.Data(year int, month time.Month, day, hour, min, sec, nsec int, loc *time.Location) time.Time
产生一个 time.Time 类型
需要 年月日 时分秒 纳秒 以及一个地点
所有的单位都会自动进位
地点必须被指定，否则会产生 panic


time.Now() time.Time
返回当前的本地时间


(time.Time) In(loc *time.Location) time.Time
将时间转化为指定地点的本地时间


(time.Time) Local() time.Time
(time.Time) UTC() time.Time
给出 time.Time 在 本地/UTC 相对应的时间


(time.Time) Unix() int64
(time.Time) UnixNano() int64
返回从 Jan 1st 1970 UTC 到指定时间的秒/纳秒数
对于纳秒，返回值不可以超过 int64 的最大容量，对应范围大致为 1678年-2262年


time.Unix(sec int64, nsec int64) time.Time
将 Unix 表示的时间转化为一个 time.Time 类型


(time.Time) Truncate(d Duration) time.Time
(time.Time) Round(d Duration) time.Time
向下或四舍五入时间，最小单位为 d
若 d<=0 则不对原数据产生修改
由于 time.Time 被转换为了相对 time.Time 的零值的 Duration
所以可能会出现小数


(time.Time) Add(d Duration) Time
(time.Time) AddDate(years int, months int, days int) Time
向一个时间点加入另一段时间，来获得新的时间


(time.Sub) Sub(u Time) Duration
两个时间点相减，并得到持续时间


(time.Time) After(u Time) bool
(time.Time) Before(u Time) bool
(time.Time) Equal(u Time) bool
时间比较，是否在指定时间之后/之前/相同


time.Parse(layout,value string) (Time, error)
将字符串按照自定的规则解析为 time.Time 类型
若缺失地点，则默认解析为 UTC 时间

time.ParseInLocation(layout, value string, loc *Location) (Time, error)
与 Parse 类似，区别在于 ParseInLocation 必须指定地点
在解析时间的时候， Parse 会将时间转换至指定地点的时区中
而 ParseInLocation 会直接认为输入的值属于该指定的地点
