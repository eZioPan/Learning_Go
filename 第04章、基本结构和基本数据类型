变量名可以以 _ 作为开头



在编译过程中，源码按照包的导入顺序编译
且没有修改过源码的包，不会再从源码编译出来



对于导入包的路径

若包路径不以 . 或 / 开头，则在 Go 的全局路径下搜索
若包路径以 . 开头，则在源码所在目录下查找
（同样适用于 Windows）若包路径以 / 开头，则在系统绝对路径下查找



设置导入包的别名

import <别名> "<包路径>"



在任何一个包中，init 函数会被第一个执行
即便在 main 包中，init 函数也是先于 main 函数被执行的



一个结构类型变量（struct、array、slice、map、channel、error等）的默认值都是 nil



在内存相关的概念中，有一种被称为 “字 word” 的概念

一个 字，就是一段标准容量的数据，一般与 CPU 在一次读取时能处理的字节数相当
也就是说，
在 32bit CPU 的构架中，一个 字 的大小一般是 32bit
在 64bit CPU 的构架中，一个 字 的大小一般是 64bit

而内存也使用相同的方式来为内存分段（也就是格式化内存的过程）
把整个内存的存储空间分为 8/16/32/64 bit 的一个一个的小格子
用来存放数据

当我们使用内存的时候，会先申请一些内存的容量
之后，系统会给我们内存的地址，让我们定位内存，用以读写

好比住一家酒店，需要先预定一些房间
成功之后，酒店返回一些门牌号，我们就可以根据门牌号，进出和使用房间



值类型

所有 int float bool string array struct 都是值类型
在这种类型中，内存中直接存放数据本身
变量中存储的是具有数据的内存的地址
将一个值类型赋值给另一个值类型的时候，拷贝的是数据本身

值类型的变量的值存储在栈中


引用类型

所有的 pointer slice map channel 都是引用类型
在这种类型中，内存中存放着指向某个数据的内存地址
变量中存储的是 存放内存地址的 内存的 内存地址
将一个引用类型赋值给另一个引用类型的时候，拷贝的是变量存储的数据本身（也就是指向底层数据的内存地址）

引用类型的变量存储在堆中



关于 fmt 包的 Printf Fprintf Sprintf 函数

fmt.Printf
普通的格式化打印

fmt.Fprintf
指定接收对象的格式化打印（接收对象必须实现了 io.Writer 接口）

fmt.Sprintf
格式化打印，并返回格式化之后的文本



fmt 包中的 Stringer 接口和 GoStringer 接口

实现了 Stringer 接口的 String() string 方法的类型
可以使用 printf 的 %v 来普通格式化打印

实现了 GoStringer 接口的 Gostring() string 方法的类型
可以使用 printf 的 %#v 来以 Go 的方式格式化打印



关于 printf 中，格式化本身的附加内容

可以用 中括号 + 数字 的方式，定义该位置将拾取的变量的位置
可以在中括号后加 星号 * 来从外部设置 格式化数据的 长度 以及 精度
位置是以 1 作为起始的
除非被手动设置，否则后续的位置将顺着当前所在的位置继续读取

EG.

# 简单的读取位置指定
fmt.Printf("%[2]v, %[1]d", 11, 22)
# 打印出 22, 11

# 带 * 的指定宽度或精度的写法
fmt.Printf("%0[2]*.[3]*[1]f", 15.0, 5, 1)
# 打印出 015.0
# 注意，小数点 . 也算一位

# 顺次读取测试
fmt.Printf("%[2]v, %v", 2, 3, 4)
# 打印 3, 4



全局变量允许只声明而不使用
