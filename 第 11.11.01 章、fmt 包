fmt 包实现了与 C 的 printf 和 scanf 函数相同的格式化 IO
格式化“动词（verb）” 由 C 引申而来，且更加简单



打印（Printing）

格式化动词

通用

	%v		值的默认格式化
			当打印结构体时，加号标识（%+v）会加上字段名称
	%#v		Go 风格的值表示
	%T		Go 风格的值的类型的表示
	%%		确切表示一个百分号


布尔值

	%t		单词 true 或 false


整型【以 int 10 为例子】

	%b		二进制值【输出 1010】
	%c		数字所定义的 Unicode 码点的字符表示【输出了一个换行符】
	%d		十进制【输出 10】
	%o		八进制【输出 12】
	%q		符合 Go 语法的，将数字表示的字符安全转义之后的，用单引号引起的输出字符【输出 '\n'】
	%x		十六进制，小写 a-f【输出 a】
	%X		十六进制，大写 A-F【输出 A】
	%U		数字的 Unicode 表示【输出 U+000A】


浮点数和复数

	%b		无小数的科学计数法，为 2 的幂
			依照 strconv.FormatFloat 的 “b” 样式设计
	%e		科学计数法，小 e 标记
	%E		科学计数法，大 E 标记
	%f		含小数点但无指数
	%F		同 %F
	%g		对于大指数使用 %e，其他使用 %f
	%G		对于大指数使用 %E，其他使用 %F


字符串和 []byte

	%s		未解析的 字符串字节流 或者 slice 字节流
	%q		符合 Go 语法的，将字符安全转义之后的，用双引号引起的输出字符串
	%x		十六进制，小写，两个字符转换为一个字节
	%X		十六进制，大写，两个字符转换为一个字节


指针

	%p		十六进制标记，前序 0x


%v 所对应的每种类型的默认参数

	布尔值			%t
	整型				%d
	无符号整型		%d，若使用 %#v 则输出 %#x
	浮点数和复数		%g
	字符串			%s
	通道				%p
	指针				%p


对于复合对象，对其中元素递归使用以下规则，入下所示：

	struct				{field0 field1 ...}
	array slice			[elem0 elem1 ...]
	map					map[key0:value0 key1:value1 ...]
	上述对象的 pointer	&{}， &[], &map[]


宽度值是一个可选值，其紧接在“动词”之前的十进制数
若缺少宽度值，则使用最小的可表示该值的宽度
精度值是紧跟在宽度之后的一个可选十进制值，精度值和宽度值之间用小数点隔开
若没有小数点出现，则使用默认的精度值
小数点后没有跟随任何值表示进精度值为 0
举例：
	%f		默认宽度，默认精度
	%9f		宽度值 9，默认精度
	%.2f	默认宽度，精度值 2
	%9.2f	宽度值 9，精度值 2
	%9.f	宽度值 9，精度值 0


宽度值和精度值的单位是单个 Unicode 码点，也就是 rune 数量（不同地，C 的 printf 使用 byte 作为单位）
任何一个标示都可以使用字符 * 代替，也就是从紧邻的操作中获取，而下一个操作所读取的数必须是 int 类型

对于大多数值，宽度是最小的输出字符数，若需要则用空格补充空白处

对于 string、byte slice 和 byte array，不同的是，精度限制了将要被格式化的输入数据的长度（而并非输出的长度），若需要则去尾
通常情况下，它按照 rune 数计算，但若使用 %x 和 %X 格式化，则使用字节数计算

对于浮点数值，宽度设置了整个字段的最小长度，精度设置了小数点后的长度
%g 和 %G 的精度设置了有效数值的个数
举例来说，给定 12.345，对于 %6.3f 得到的字符串是 12.345 ，对于 %.3g 得到的是 12.3
%e 和 %f 的默认精度值是 6，%g 是唯一确定数字的值的最小长度

对于复数，分别针对复数的两个部分独立设置宽度和精度

其他标示

+ 	永远打印数值类型的符号
	对于 %q 永远打印出仅 ASCII 的字符

-	对于补空的部分，全部采取左对齐，而非右对齐

#	替换格式化：	对于 八进制 添加前序的 0
				对于 十六进制 添加前序的 0x 或 0X
				对于  %p 抑制前序的 0x

' '	空格）为数字隐去的符号留一个空格位
	在 字符串 或者 slice 的每个字节之间打印一个空格

0 	使用 0 替代空格填充前序空位
	对于数字，在符号后填充空位


若格式字符本身并不接受某标示，则会忽略它
举个例子，若没有多余的小数可以格式化，则 %#d 和 %d

对于每个 Printf 类似的函数，都有一个 Print 函数与之对应，也就是没有格式化的字符串，或者说 %v 的操作
另一个替代者 Println 会在每个操作之后插入一个新行

无论“动词”是什么，若一个操作是作用于 interface 的值，则 interface 的值会被使用，而非 interface 自身
也就是：
	var i interface{} = 23
	fmt.Printf("%v\n", i)
将会打印 23


除了使用 %T 和 %p 两个“动词”，特殊的格式会作用于特定的 interface
按照以下的顺序进行赋值：
	<1>	若要操作的值是 reflect.Value，则操作的值被其具有的底层值所替代
		打印过程继续下一个规则
	<2>	若要操作的值是 Formatter interface，则它会被调用
		Formatter 会精细地操作格式化过程
	<3>	若“动词” %v 和标示 # 连用（%#v），且所要操作的值满足了 GoStringer interface
		则 GoString 方法会被调用

	若格式化（例如 %v 之于 Println）对于字符串（%s %q %v %x %X）是合法的
	执行接下来的两个规则
	<4>	若要操作的值满足了 error interface，则 Error 方法会被调用，将该对象转换为 字符串
		并被对应的“动词”（若有的话）格式化
	<5>	若要操作的值满足了 String() string 方法，则该方法会被调用，并将该对象转换为 字符串
		并被对应的“动词”（若有的话）格式化


对于复合对象，比如 slice 和 struct，格式化递归作用于所操作的值的内部每一个元素，而非作用于被操作的值本身
也就是说，%q 会给 []string 中的每个字符串加引号， %6.2f 会给 浮点数组中的每个浮点数格式化

但是，当使用 字符串类似的“动词”（%s %q %x %X）打印一个 []byte，该 []byte 等价于一个字符串，将视作一个单一对象


为了防止循环递归的情况发生，如：

	type X string
	func (x X) String() string{
		return Sprintf("<%s>", x)
	}

在循环发生前，先转换值类型：

	func (x X) String() string{
		return Sprintf("<%s>", string(x))
	}


无限递归循环也可以被自引用的数据结构触发，比如一个包含自身作为元素的 slice，且该类型又具有 String 方法
这种情况及其少见，但是，这个包并不能保护程序不犯这种这种错误

当打印 struct 时，fmt 不能也无法对非导出字段调用类似 Error 或者 String 的格式化方法


明确指定参数的索引号：

在 Printf Sprintf 和 Fprintf 中，默认的行为是，对于每个格式化“动词”，顺次格式化传入的参数
但是，标记 [n] 立刻将“动词”所要格式化的参数变为第 n 个参数，n 是以 1 开头的参数的索引
在紧贴在星号 * 前的 [n] 标记，把星号所取得值的索引指向 n
在处理了 [n] 所在的操作之后，其后的“动词”将顺次使用 n+1 n+2 等等索引的参数，除非其他的 [n] 出现

举例来说：

fmt.Sprintf("%[2]d %[1]d\n", 11, 22)

将输出 22 11

fmt.Sprintf("%[3]*.[2]*[1]f", 12.0, 2, 6)

等价于

fmt.Sprintf("6.2f", 12.0)

将返回 12.00

由于 明确指定了参数的索引号，也会影响剩余的“动词”，这种标示也可以用于多次打印相同的值
只需要反复指定同一个相同的值即可

fmt.Sprintf("%d %d %#[1]x %#x", 16, 17)

将返回 16 17 0x10 0x11


格式化错误：

若对一个“动词”传入了非法的参数，比如 给 %d 传入了一个字符串，则生成的字符串将会包含一个问题的描述
如下所示：

错误的类型或未知的“动词”： %!verb(type=value)
	Printf("%d", hi):			%!d(string=hi)

过多的参数： %!(EXTRA type=value)
	Printf("hi", "guys"):		hi%!(EXTRA string=guys)

过少的参数： %!verb(MISSING)
	Printf("hi%d"):				hi%1d(MISSING)

对于宽度和精度使用了非 int 值：	%!(BADWIDTH) 或 %!(BADPREC)
	Printf("%*s", 4.5, "hi"):	%!(BADWIDTH)hi
	Printf("%.*s", 4.5, "hi"):	%!(BADPREC)hi

非法的，或者非法使用的参数索引： %!(BADINDEX)
	Printf("%*[2]d", 7):		%!d(BADINDEX)
	Printf("%.[2]d", 7):		%!d(BADINDEX)

所有的错误都以字符串 “%!” 作为开始，有事紧随一个单字符（也就是“动词”）接着以括号括起的描述做结尾

在 print 的过程中，有一个 Error 或者 String 方法触发了一个 panic， fmt 包会重新格式化错误信息
装饰错误信息来指明它从 fmt 包传递出来
举例来说，若一个 String 方法调用了 panic("bad") 那么得到的格式化字符串将有如下的样子

%!s(PANIC=bad)

%!s 显示了错误产生时，使用的打印“动词”
若 panic 由 Error 或 String 方法的接受者为 nil 造成，则输出的未未装饰的字符串 “<nil>”
